---
layout: post
title: 'Exemplos de funções: fread(), fwrite(), remove() e outras em C'
date: '2014-10-29T18:01:00.000-07:00'
author: Marcos Oliveira
tags:
- Linguagem C
modified_time: '2014-10-29T18:01:36.537-07:00'
thumbnail: http://2.bp.blogspot.com/-ALBejyjhrGI/UaKms_oM2hI/AAAAAAAABok/uhtHGNuBjM8/s72-c/function+c.png
blogger_id: tag:blogger.com,1999:blog-2422865715758349944.post-5124006667400098123
blogger_orig_url: http://www.terminalroot.com.br/2014/10/exemplos-de-funcoes-fread-fwrite-remove.html
---

<div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-ALBejyjhrGI/UaKms_oM2hI/AAAAAAAABok/uhtHGNuBjM8/s1600/function+c.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-ALBejyjhrGI/UaKms_oM2hI/AAAAAAAABok/uhtHGNuBjM8/s320/function+c.png" height="173" width="320" /></a></div><br /><br /><br /><br /><b><span style="color: blue;"><span style="font-size: large;">fread()</span></span></b><br /><blockquote class="tr_bq"><b><span style="font-size: x-small;">Podemos escrever e ler blocos de dados. Para tanto, temos as funções fread() e fwrite(). O protótipo de fread() é:</span></b><br /><br /><b><span style="font-size: x-small;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;unsigned fread (void *buffer, int numero_de_bytes, int count, FILE *fp);</span></b><br /><b><span style="font-size: x-small;">&nbsp;&nbsp; </span></b><br /><b><span style="font-size: x-small;">O buffer é a região de memória na qual serão armazenados os dados lidos. O número de bytes é o tamanho da unidade a ser lida. count indica quantas unidades devem ser lidas. Isto significa que o número total de bytes lidos é:</span></b><br /><br /><b><span style="font-size: x-small;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;numero_de_bytes*count</span></b><br /><b><span style="font-size: x-small;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </span></b><br /><b><span style="font-size: x-small;">A função retorna o número de unidades efetivamente lidas. Este número pode ser menor que count quando o fim do arquivo for encontrado ou ocorrer algum erro.</span></b><br /><b><span style="font-size: x-small;">Quando o arquivo for aberto para dados binários, fread pode ler qualquer tipo de dados.</span></b></blockquote><b><br /><i><u>Exemplo:</u></i><br /><div class="adp"><br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br /><br />int main()<br />{<br />&nbsp;&nbsp; &nbsp;// Declaramos um ponteiro(link para o endereço da memória) para o arquivo de nome: 'pf'<br />&nbsp;&nbsp; &nbsp;FILE *pf;<br />&nbsp;&nbsp; &nbsp;char conteudo[100];<br /><br />&nbsp;&nbsp; &nbsp;pf = fopen("arquivos/texto.txt", "rb"); /* Abre o arquivo novamente para leitura */<br /><br />&nbsp;&nbsp; &nbsp;fread(&amp;conteudo, sizeof(char), 100,pf); /* Le em conteudo o valor da variável armazenada anteriormente pf */<br /><br />&nbsp;&nbsp; &nbsp;printf("\nO conteúdo do arquivo é':\n %s \n", conteudo);<br />&nbsp;&nbsp; <br />&nbsp;&nbsp; &nbsp;fclose(pf);<br />&nbsp;&nbsp; <br />&nbsp;&nbsp; &nbsp;return(0);<br />}</div><br /><br /><span style="color: blue;"><span style="font-size: large;">fwrite()</span></span></b><br /><blockquote class="tr_bq"><b><span style="font-size: x-small;">A função fwrite() funciona como a sua companheira fread(), porém escrevendo no arquivo. Seu protótipo é:</span></b><br /><br /><b><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned fwrite(void *buffer,int numero_de_bytes,int count,FILE *fp);</span></b><br /><b><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></b><br /><b><span style="font-size: x-small;">A função retorna o número de itens escritos. Este valor será igual a count a menos que ocorra algum erro.</span></b></blockquote><b><br /><u><i>Exemplo:</i></u><br /><br /><div class="adp"><br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />int main()<br />{<br />FILE *pf;<br />int NUM = 88;<br />int pilido;<br />if((pf = fopen("arquivos/arquivo.bin", "wb")) == NULL) /* Abre arquivo binário para escrita */<br />{<br />&nbsp;&nbsp;&nbsp; printf("Erro na abertura do arquivo");<br />&nbsp;&nbsp;&nbsp; exit(1);<br />}<br />if(fwrite(&amp;NUM, sizeof(int), 1,pf) != 1)&nbsp;&nbsp;&nbsp;&nbsp; /* Escreve a variável NUM | o operador sizeof, que retorna o tamanho em bytes da variável ou do tipo de dados. */<br />&nbsp;&nbsp;&nbsp; printf("Erro na escrita do arquivo");<br />fclose(pf);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Fecha o arquivo */<br />if((pf = fopen("arquivos/arquivo.bin", "rb")) == NULL) /* Abre o arquivo novamente para leitura */<br />{<br />&nbsp;&nbsp;&nbsp; printf("Erro na abertura do arquivo");<br />&nbsp;&nbsp;&nbsp; exit(1);<br />}<br />if(fread(&amp;pilido, sizeof(int), 1,pf) != 1) /* Le em pilido o valor da variável armazenada anteriormente */<br />&nbsp;&nbsp;&nbsp; printf("Erro na leitura do arquivo");<br />printf("\nO valor de NUM, lido do arquivo e': %d \n\n", pilido);<br />fclose(pf);<br />return(0);<br />}</div><br /><br /><span style="color: blue;"><span style="font-size: large;">remove()</span></span><br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </b><br /><blockquote class="tr_bq"><b><span style="font-size: x-small;">Protótipo:</span></b><br /><br /><b><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp;&nbsp; int remove (char *nome_do_arquivo);</span></b><br /><b><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp; </span></b><br /><b><span style="font-size: x-small;">Apaga um arquivo especificado.</span></b></blockquote><b><br /><u><i>Exemplo:</i></u><br /><br /><div class="adp"><br />#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />#include &lt;stdlib.h&gt;<br />int main()<br />{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;/*&nbsp; 0(zero) é verdadeiro(true), e 1(um) é falso(false), em C usa-se números! */<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(remove("arquivo_a_ser_removido.txt") == 0){<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;printf("Arquivo removido com sucesso!\n");<br />&nbsp; &nbsp;&nbsp; &nbsp;}else{<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;printf("Não removido, talvez não exista.\n");<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />&nbsp;&nbsp;&nbsp; return(0);<br />}</div><br /><br /><br /><span style="color: blue;"><span style="font-size: large;">fprintf() e fscanf()</span></span></b><br /><blockquote class="tr_bq"><b><span style="font-size: x-small;">Os fluxos padrão em arquivos permitem ao programador ler e escrever em arquivos da maneira padrão com a qual o já líamos e escrevíamos na tela.</span></b><br /><br /><b><span style="font-size: x-small;">fprintf():</span></b><br /><br /><b><span style="font-size: x-small;">A função fprintf() funciona como a função printf(). A diferença é que a saída de fprintf() é um arquivo e não a tela do computador. Protótipo:</span></b><br /><b><span style="font-size: x-small;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int fprintf (FILE *fp,char *str,...);</span></b><br /><b><span style="font-size: x-small;">Como já poderíamos esperar, a única diferença do protótipo de fprintf() para o de printf() é a especificação do arquivo destino através do ponteiro de arquivo.</span></b><br /><br /><b><span style="font-size: x-small;">fscanf():</span></b><br /><br /><b><span style="font-size: x-small;">A função fscanf() funciona como a função scanf(). A diferença é que fscanf() lê de um arquivo e não do teclado do computador.</span></b></blockquote><b><br /><u><i>Exemplo de fprintf e fscanf:</i></u><br /><br /><div class="adp"><br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />int main()<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE *p;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char str[80],c;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Le um nome para o arquivo a ser aberto: */<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("\n\n Entre com um nome para o arquivo:\n");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scanf("%s", &amp;str); /* não se usa a função gets() e sim scanf dessa forma */<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(p = fopen(str,"w"))) /* Caso ocorra algum erro na abertura do arquivo..*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* o programa aborta automaticamente */<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Erro! Impossivel abrir o arquivo!\n");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Se nao houve erro, imprime no arquivo, fecha ...*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(p,"Este e um arquivo chamado(com ou sem caminho e formato):\n%s\n", str);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose(p);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* abre novamente para a leitura&nbsp;&nbsp; */<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p = fopen(str,"r");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (!feof(p))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fscanf(p,"%c",&amp;c);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("%c",c);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose(p);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(0);<br />}</div><br /><br /><span style="color: blue;"><span style="font-size: large;">fputs()</span></span></b><br /><blockquote class="tr_bq"><b><span style="font-size: x-small;">Os C biblioteca de funções int fputs (const char * str, FILE * stream) escreve uma string para o fluxo especificado até, mas não incluindo o caractere nulo.</span></b><br /><b><span style="font-size: x-small;">Declaração</span></b><br /><br /><b><span style="font-size: x-small;">Segue-se a declaração para a função fputs ():</span></b><br /><br /><b><span style="font-size: x-small;">&nbsp;int fputs (const char * str, FILE * stream)</span></b><br /><br /><b><span style="font-size: x-small;">Parâmetros</span></b><br /><br /><b><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp; str - Este é um array contendo a seqüência de terminação nula de caracteres a serem escritos.</span></b><br /><br /><b><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp; fluxo - Este é o ponteiro para um objeto de arquivo que identifica o fluxo onde a corda está a ser escrito. </span></b><br /><br /><b><span style="font-size: x-small;">Valor de retorno</span></b><br /><br /><b><span style="font-size: x-small;">Escreve uma string num arquivo.</span></b><br /><b><span style="font-size: x-small;">Esta função retorna um valor não-negativo mais, em caso de erro devolve EOF.</span></b></blockquote><b><br /><u><i>Exemplo</i></u>:<br /><br /><div class="adp"><br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;string.h&gt;<br />int main()<br />{<br />&nbsp; FILE *fp;<br /><br />&nbsp; fp = fopen("arquivos/fputs.txt", "w+");<br /><br />&nbsp; fputs("Esta é a programação c.", fp);<br />&nbsp; fputs("Esta é uma linguagem de programação do sistema.", fp);<br /><br />&nbsp; fclose(fp);<br /><br />&nbsp; return(0);<br />}</div><br /><span style="color: #274e13;">Vamos compilar e executar o programa acima, isso vai criar um arquivo.txt arquivo com o seguinte conteúdo:&nbsp;</span></b><br /><b><span style="font-size: x-small;"><span style="color: #660000;">Esta é a programação c.Esta é uma linguagem de programação do sistema. </span></span><br /><br /><span style="color: blue;"><span style="font-size: large;">fgets()</span></span></b><br /><blockquote class="tr_bq"><b><span style="font-size: x-small;">Para se ler uma string num arquivo podemos usar fgets() cujo protótipo é:</span></b><br /><br /><b><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *fgets (char *str, int tamanho,FILE *fp);</span></b><br /><b><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></b><br /><b><span style="font-size: x-small;">A função recebe 3 argumentos: a string a ser lida, o limite máximo de caracteres a serem lidos e o ponteiro para FILE, que está associado ao arquivo de onde a string será lida.A função lê a string até que um caracter de nova linha seja lido ou tamanho-1 caracteres tenham sido lidos. Se o caracter de nova linha ('\n') for lido, ele fará parte da string, o que não acontecia com gets. A string resultante sempre terminará com '\0' (por isto somente tamanho-1 caracteres, no máximo, serão lidos). A função fgets é semelhante à função gets(), porém, além dela poder fazer a leitura a partir de um arquivo de dados e incluir o caracter de nova linha na string, ela ainda especifica o tamanho máximo da string de entrada. Como vimos, a função gets não tinha este controle, o que poderia acarretar erros de "estouro de buffer". Portanto, levando em conta que o ponteiro fp pode ser substituído por stdin, como vimos acima, uma alternativa ao uso de gets é usar a seguinte construção:</span></b><br /><br /><b><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fgets (str, tamanho, stdin);</span></b><br /><b><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></b><br /><b><span style="font-size: x-small;">onde str e' a string que se está lendo e tamanho deve ser igual ao tamanho alocado para a string subtraído de 1, por causa do '\0'.</span></b></blockquote><b><br /><u><i>Exemplo:</i></u><br /><br /><div class="adp"><br />#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />#include &lt;stdlib.h&gt;<br />int main()<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE *p;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char str[30], frase[] = "Este e um arquivo chamado: ", resposta[80];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Le um nome para o arquivo a ser aberto: */<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("\n\n Entre com um nome para o arquivo:\n");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fgets(str,29,stdin);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Usa fgets como se fosse gets */<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i=0; str[i]; i++) if(str[i]=='\n') str[i]=0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Elimina o \n da string lida */<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(p = fopen(str,"w")))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Caso ocorra algum erro na abertura do arquivo..*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* o programa aborta automaticamente */<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Erro! Impossivel abrir o arquivo!\n");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Se nao houve erro, imprime no arquivo, e o fecha ...*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputs(frase, p);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputs(str,p);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose(p);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* abre novamente e le */<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p = fopen(str,"r");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fgets(resposta, 79, p);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("\n\n%s\n", resposta);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose(p);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Fecha o arquivo */<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove(str);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Apaga o arquivo */<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(0);<br />}</div><br /><br /><br /><span style="color: blue;"><span style="font-size: large;">ferror() e perror()</span></span></b><br /><blockquote class="tr_bq"><b><span style="font-size: x-small;">Protótipo de ferror:</span></b><br /><b><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ferror (FILE *fp);</span></b><br /><b><span style="font-size: x-small;">A função retorna zero, se nenhum erro ocorreu e um número diferente de zero se algum erro ocorreu durante o acesso ao arquivo.</span></b><br /><b><span style="font-size: x-small;">ferror() se torna muito útil quando queremos verificar se cada acesso a um arquivo teve sucesso, de modo que consigamos garantir a integridade dos nossos dados. Na maioria dos casos, se um arquivo pode ser aberto, ele pode ser lido ou gravado. Porém, existem situações em que isto não ocorre. Por exemplo, pode acabar o espaço em disco enquanto gravamos, ou o disco pode estar com problemas e não conseguimos ler, etc. Uma função que pode ser usada em conjunto com ferror() é a função perror() (print error), cujo argumento é uma string que normalmente indica em que parte do programa o problema ocorreu.</span></b></blockquote><b><br /><u><i>Exemplo:</i></u><br /><br /><div class="adp"><br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;string.h&gt;<br />int main()<br />{<br />&nbsp; FILE *pf;<br />&nbsp; char string[100];<br />&nbsp; if((pf = fopen("arquivo.txt","w")) ==NULL)<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("\nNao consigo abrir o arquivo ! ");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);<br />&nbsp; }<br />&nbsp; do<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("\nDigite uma nova string. Para terminar, digite &lt;enter&gt;: ");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scanf("%s", &amp;string); /* não se usa a função gets() e sim scanf dessa forma */<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputs(string, pf);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putc('\n', pf);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(ferror(pf))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror("Erro na gravacao");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose(pf);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp; } while (strlen(string) &gt; 0);<br />&nbsp; fclose(pf);<br />}</div><br /><br /><span style="color: blue;"><span style="font-size: large;">fseek()</span></span></b><br /><blockquote class="tr_bq"><b><span style="font-size: x-small;">Para se fazer procuras e acessos randômicos em arquivos usa-se a função fseek(). Esta move a posição corrente de leitura ou escrita no arquivo de um valor especificado, a partir de um ponto especificado. Seu protótipo é:</span></b><br /><br /><b><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int fseek (FILE *fp,long numbytes,int origem);</span></b><br /><b><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></b><br /><b><span style="font-size: x-small;">O parâmetro origem determina a partir de onde os numbytes de movimentação serão contados. Os valores possíveis são definidos por macros em stdio.h e são:</span></b></blockquote><b><br />Nome&nbsp;&nbsp;&nbsp; Valor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Significado<br /><br />SEEK_SET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Início do arquivo<br />SEEK_CUR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ponto corrente no arquivo<br />SEEK_END&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fim do arquivo<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /><span style="color: #274e13;"><span style="font-size: x-small;"><i>Tendo-se definido a partir de onde irá se contar, numbytes determina quantos bytes de deslocamento serão dados na posição atual.</i></span></span><br /><br /><span style="color: blue;"><span style="font-size: large;">rewind()</span></span></b><br /><blockquote class="tr_bq"><b><span style="font-size: x-small;">A função rewind() de protótipo:</span></b><br /><br /><b><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp; void rewind (FILE *fp);</span></b><br /><b><span style="font-size: x-small;">&nbsp;&nbsp; </span></b><br /><b><span style="font-size: x-small;">retorna a posição corrente do arquivo para o início.</span></b></blockquote>