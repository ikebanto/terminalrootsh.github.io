---
layout: post
title: O comando xargs
date: '2014-10-19T08:06:00.000-07:00'
description: O comando xargs
main-class: 'bash'
color: '#c2003a'
author: Marcos Oliveira
tags:
- Shell Script
- Comandos
modified_time: '2014-10-19T08:06:12.353-07:00'
twitter_text: O comando xargs
introduction: O comando xargs
---

<p>
<h2>Passando parâmetros com xargs</h2>Existe um comando, cuja função primordial é construir listas de  parâmetros e passá-la para a execução de outros programas ou instruções.  Este comando é o {% highlight bash %}xargs{% endhighlight %} e deve ser usado da seguinte maneira:</p><p><pre>    xargs [comando [argumento inicial]]</pre>{% highlight bash %}xargs{% endhighlight %} combina o argumento inicial com os argumentos  recebidos da entrada padrão, de forma a executar o comando especificado  uma ou mais vezes.</p><p><kbd>Exemplo:</kbd></p><p>Vamos procurar em todos os arquivos abaixo de um determinado diretório uma cadeia de caracteres usando o comando {% highlight bash %}find{% endhighlight %} com a opção {% highlight bash %}-type f{% endhighlight %} para pesquisar somente os arquivos normais, desprezando diretórios,  arquivos especiais, arquivos de ligações, etc, e vamos torná-la mais  genérica recebendo o nome do diretório inicial e a cadeia a ser  pesquisada como parâmetros. Para isso fazemos:</p><p><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ cat grepr<span style="color: white;"></p><p>#</p><p># Grep recursivo</p><p># Pesquisa a cadeia de caracteres definida em $2 a partir do diretorio $1</p><p>#</p><p>find $1 -type f -print|xargs grep -l “$2″</span></div>Na execução deste script procuramos, a partir do diretório definido na variável {% highlight bash %}$1{% endhighlight %}, todos os arquivos que continham a cadeia definida na variável {% highlight bash %}$2{% endhighlight %}.</p><p>Exatamente a mesma coisa poderia ser feito se a linha do programa fosse a seguinte:</p><p><pre>    find $1 -type f -exec grep -l "$2" {} \;</pre>O primeiro processo tem duas grandes desvantagens sobre o anterior:</p><p><ul><li> A primeira é bastante visível: o tempo de execução deste método é muito superior ao daquele, isso porque o {% highlight bash %}grep{% endhighlight %} será feito em cada arquivo que lhe for passado pelo {% highlight bash %}find{% endhighlight %}, um-a-um, ao passo que com o {% highlight bash %}xargs{% endhighlight %}, será passada toda, ou na pior das hipóteses, a maior parte possível, da lista de arquivos gerada pelo {% highlight bash %}find{% endhighlight %};</li></ul><ul><li> Dependendo da quantidade de arquivos encontrados que atendem ao {% highlight bash %}find{% endhighlight %}, poderemos ganhar aquela famosa e fatídica mensagem de erro {% highlight bash %}Too many arguments{% endhighlight %} indicando um estouro da pilha de execução do {% highlight bash %}grep{% endhighlight %}. Como foi dito no item anterior, se usarmos o {% highlight bash %}xargs{% endhighlight %} ele passará para o {% highlight bash %}grep{% endhighlight %} a maior quantidade de parâmetros possível, suficiente para não causar este erro, e caso necessário executará o {% highlight bash %}grep{% endhighlight %} mais de uma vez.</li></ul><div style="background-color: #ffffcc; border: 1px dashed red; margin: 1em; min-height: 105px; padding: 1em;"><img alt="Pinguim com placa de atenção" src="http://twiki.softwarelivre.org/pub/TWikiBar/FreeSkinImagens/pinguim_atencao.gif" style="float: left; padding: 0 8px 0 0;" /> Aê pessoal do linux que usa o {% highlight bash %}ls{% endhighlight %} colorido que nem porta de tinturaria: nos exemplos a seguir que envolvem esta instrução, você devem usar a opção {% highlight bash %}--color=none{% endhighlight %}, senão existem grandes chances dos resultados não ocorrerem como o esperado.</div>Vamos agora analisar um exemplo que é mais ou menos o inverso deste que acabamos de ver. Desta vez, vamos fazer um <i>script</i> para remover todos os arquivos do diretório corrente, pertencentes a um determinado usuário.</p><p>A primeira idéia que surge é, como no caso anterior, usar um comando {% highlight bash %}find{% endhighlight %}, da seguinte maneira:</p><p><pre>    find . -user cara -exec rm -f {} \;</pre>Quase estaria certo, o problema é que desta forma você removeria não só os arquivos do {% highlight bash %}cara{% endhighlight %} no diretório corrente, mas também de todos os outros subdiretórios “pendurados” neste. Vejamos então como fazer:</p><p><pre>    ls -l | grep " cara " | cut -c55- | xargs rm</pre>Desta forma, o {% highlight bash %}grep{% endhighlight %} selecionou os arquivos que continham a cadeia {% highlight bash %}cara{% endhighlight %} no diretório corrente listado pelo {% highlight bash %}ls -l{% endhighlight %}. O comando {% highlight bash %}cut{% endhighlight %} pegou somente o nome dos arquivos, passando-os para a remoção pelo {% highlight bash %}rm{% endhighlight %} usando o comando {% highlight bash %}xargs{% endhighlight %} como ponte</p><p>O xargs é também uma excelente ferramenta de criação de <i>one-liners</i> (<i>scripts</i> de somente uma linha). Veja este para listar todos os donos de arquivos (inclusive seus <i>links</i>) “pendurados” no diretório {% highlight bash %}/bin{% endhighlight %} e seus subdiretórios.</p><p><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ find /bin -type f -follow | \</p><p>xargs ls -al | tr -s ‘ ‘ | cut -f3 -d’ ‘ | sort -u</div>Muitas vezes o {% highlight bash %}/bin{% endhighlight %} é um <i>link</i> (se não me engano, no Solaris o é) e a opção {% highlight bash %}-follows{% endhighlight %} obriga o {% highlight bash %}find{% endhighlight %} a seguir o <i>link</i>. O comando {% highlight bash %}xargs{% endhighlight %} alimenta o {% highlight bash %}ls -al{% endhighlight %} e a seqüência de comandos seguinte é para pegar somente o 3º campo  (dono) e classificá-lo devolvendo somente uma vez cada dono (opção {% highlight bash %}-u{% endhighlight %} do comando {% highlight bash %}sort{% endhighlight %}, que equivale ao comando {% highlight bash %}uniq{% endhighlight %}).</p><p><h3><a href="https://www.blogger.com/null" name="Opções_do_xargs" title="Opções_do_xargs"></a> Opções do xargs</h3>Você pode usar as opções do {% highlight bash %}xargs{% endhighlight %} para construir comandos extremamente poderosos.</p><p><h4><a href="https://www.blogger.com/null" name="Opção_i" title="Opção_i"></a> Opção -i</h4>Para exemplificar isso e começar a entender as principais opções  desta instrução, vamos supor que temos que remover todos as arquivos com  extensão {% highlight bash %}.txt{% endhighlight %} sob o diretório corrente e apresentar os seus nomes na tela. Veja o que podemos fazer:</p><p><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ find . -type f -name “*.txt” | \</p><p>xargs -i bash -c “echo removendo {}; rm {}”</div>A opção {% highlight bash %}-i{% endhighlight %} do {% highlight bash %}xargs{% endhighlight %} troca pares de chaves {% highlight bash %}({}){% endhighlight %} pela cadeia que está recebendo pelo pipe {% highlight bash %}(|){% endhighlight %}. Então neste caso as chaves {% highlight bash %}({}){% endhighlight %} serão trocadas pelos nomes dos arquivos que satifaçam ao comando {% highlight bash %}find{% endhighlight %}.</p><p><h4><a href="https://www.blogger.com/null" name="Opção_n" title="Opção_n"></a> Opção -n</h4>Olha só a brincadeira que vamos fazer com o {% highlight bash %}xargs{% endhighlight %}:</p><p><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ ls | xargs echo &gt; <span class="skimlinks-unlinked">arq.ls</span></p><p>$ cat <span class="skimlinks-unlinked">arq.ls</span><span style="color: white;"></p><p><span class="skimlinks-unlinked">arq.ls</span> arq1 arq2 arq3</span></p><p>$ cat <span class="skimlinks-unlinked">arq.ls</span> | xargs -n1<span style="color: white;"></p><p><span class="skimlinks-unlinked">arq.ls</span></p><p>arq1</p><p>arq2</p><p>arq3</span></div>Quando mandamos a saída do {% highlight bash %}ls{% endhighlight %} para o arquivo usando o {% highlight bash %}xargs{% endhighlight %}, comprovamos o que foi dito anteriormente, isto é, o {% highlight bash %}xargs{% endhighlight %} manda tudo que é possível (o suficiente para não gerar um estouro de pilha) de uma só vez. Em seguida, usamos a opção {% highlight bash %}-n 1{% endhighlight %} para listar um por vez. Só para dar certeza veja o exemplo a seguir, quando listaremos dois em cada linha:</p><p><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ cat <span class="skimlinks-unlinked">arq.ls</span> | xargs -n 2<span style="color: white;"></p><p><span class="skimlinks-unlinked">arq.ls</span> arq1</p><p>arq2 arq3</span></div>Mas a linha acima poderia (e deveria) ser escrita sem o uso de <i>pipe</i> {% highlight bash %}(|){% endhighlight %}, da seguinte forma:</p><p><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ xargs -n 2 &lt; <span class="skimlinks-unlinked">arq.ls</span></div><h4><a href="https://www.blogger.com/null" name="Opção_p" title="Opção_p"></a> Opção -p</h4>Outra opção legal do {% highlight bash %}xargs{% endhighlight %} é a {% highlight bash %}-p{% endhighlight %}, na qual o  sistema pergunta se você realmente deseja executar o comando. Digamos  que em um diretório você tenha arquivos com a extensão {% highlight bash %}.bug{% endhighlight %} e {% highlight bash %}.ok{% endhighlight %}, os {% highlight bash %}.bug{% endhighlight %} estão com problemas que após corrigidos são salvos como {% highlight bash %}.ok{% endhighlight %}. Dá uma olhadinha na listagem deste diretório:</p><p><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ ls dir<span style="color: white;"></p><p>arq1.bug</p><p>arq1.ok</p><p>arq2.bug</p><p>arq2.ok</p><p>…</p><p>arq9.bug</p><p>arq9.ok</span></div>Para comparar os arquivos bons com os defeituosos, fazemos:</p><p><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ ls | xargs -p -n2 diff -c<span style="color: white;"></p><p>diff -c arq1.bug arq1.ok ?…y</p><p>….</p><p>diff -c arq9.bug arq9.ok ?…y</span></div><h4><a href="https://www.blogger.com/null" name="Opção_t" title="Opção_t"></a> Opção -t</h4>Para finalizar, o {% highlight bash %}xargs{% endhighlight %} também tem a opção {% highlight bash %}-t{% endhighlight %},  onde vai mostrando as instruções que montou antes de executá-las. Gosto  muito desta opção para ajudar a depurar o comando que foi montado.</p><p><h4><a href="https://www.blogger.com/null" name="Resumo" title="Resumo"></a> Resumo</h4>Então podemos resumir o comando de acordo com a tabela a seguir:</p><p><table border="0" cellpadding="4" cellspacing="1" class="twikiTable"><tbody><tr><td bgcolor="#bbbbbb" class="twikiFirstCol"><b>Opção</b></td><td bgcolor="#bbbbbb"><b>Ação</b></td></tr><tr><td align="center" bgcolor="#dddddd" class="twikiFirstCol">{% highlight bash %}-i{% endhighlight %}</td><td bgcolor="#dddddd">Substitui o par de chaves {% highlight bash %}({}){% endhighlight %} pelas cadeias recebidas</td></tr><tr><td align="center" bgcolor="#bbbbbb" class="twikiFirstCol">{% highlight bash %}-nNum{% endhighlight %}</td><td bgcolor="#bbbbbb">Manda o máximo de parâmetros recebidos, até o máximo de Num para o comando a ser executado</td></tr><tr><td align="center" bgcolor="#dddddd" class="twikiFirstCol">{% highlight bash %}-lNum{% endhighlight %}</td><td bgcolor="#dddddd">Manda o máximo de linhas recebidas, até o máximo de Num para o comando a ser executado</td></tr><tr><td align="center" bgcolor="#bbbbbb" class="twikiFirstCol">{% highlight bash %}-p{% endhighlight %}</td><td bgcolor="#bbbbbb">Mostra a linha de comando montada e pergunta se deseja executá-la</td></tr><tr><td align="center" bgcolor="#dddddd" class="twikiFirstCol">{% highlight bash %}-t{% endhighlight %}</td><td bgcolor="#dddddd">Mostra a linha de comando montada antes de executá-la</td></tr></tbody></table>

</p>
