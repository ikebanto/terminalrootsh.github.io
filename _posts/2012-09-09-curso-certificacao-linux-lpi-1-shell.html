---
layout: post
title: 'Curso Certificação Linux LPI-1: Shell Script Noções Fundamentais.'
date: '2012-09-09T12:52:00.000-07:00'
description: 'Curso Certificação Linux LPI-1: Shell Script Noções Fundamentais.'
main-class: 'linux'
color: '#3b5998'
author: The Bang Bash
tags:
- Linux
- LPI
modified_time: '2013-05-03T07:16:07.416-07:00'
thumbnail: http://1.bp.blogspot.com/-dZJHH2Atcpo/UEzyBdGs6RI/AAAAAAAAAfA/Q_WWmQk1Xvw/s72-c/a.png
twitter_text: 'Curso Certificação Linux LPI-1: Shell Script Noções Fundamentais.'
introduction: 'Curso Certificação Linux LPI-1: Shell Script Noções Fundamentais.'
---

<p>
<!-------------------------------------------------> <script type="text/javascript"><!-- google_ad_client = "ca-pub-5528601613414387"; google_ad_host = "pub-1556223355139109"; /* quadrados */ google_ad_slot = "9713010559"; google_ad_width = 200; google_ad_height = 200; //</script>--&gt; <script src="http://pagead2.googlesyndication.com/pagead/show_ads.js" type="text/javascript"></script> <!-----------------------------------------------></p><p><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-dZJHH2Atcpo/UEzyBdGs6RI/AAAAAAAAAfA/Q_WWmQk1Xvw/s1600/a.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="263" src="http://1.bp.blogspot.com/-dZJHH2Atcpo/UEzyBdGs6RI/AAAAAAAAAfA/Q_WWmQk1Xvw/s400/a.png" width="400" /></a></div></p><p></p><p></p><p><b>Vamos inciar um curso de <span style="color: blue;">Shell Script</span> aqui e pra começar do início devemos aprender alguns comandos Linux, não todos, porque são tantos que parecem infinitos(risos), mas vou citar os principais e os que eu mais uso.</b></p><p><b></p><p></b></p><p><blockquote class="tr_bq"><b>Shell script é uma linguagem de script usada em vários sistemas operativos (operacionais), com diferentes dialetos, dependendo do interpretador de comandos utilizado. Um exemplo de interpretador de comandos é o bash, usado na grande maioria das distribuições GNU/Linux.Linux possui o Case Sensitive, ou seja, diferencia Maiúsculas de minúsculas.</b></blockquote><b></p><p></b></p><p><b>Essa linguagem foi a primeira Linguagem de Programação que eu aprendi, ela é bme simples e útil para agilizar sua tarefas, então, vamos aos comandos, pra iniciar é necessário que pelo próprio Bash podemos aprender os comandos, utilizando: man COMANDO ou COMANDO --help.</b></p><p></p><p>{% highlight bash %}</p><p><b># <span style="color: blue;">ls</span> - mostra arquivos e diretórios de um determinado Diretório (ls -a, também mostra arquivos ocultos), (ls -l, mostra as permissões)...</p><p># <span style="color: blue;">mkdir</span> - cria um diretório, ex.: mkdir teste esse comando cria o diretório, pasta, de nome: teste).</p><p># <span style="color: blue;">cp</span> - copia arquivos, cp [origem] [destino], ex.: cp /home/meuusuario/arquivo.x /home/meuusuario/Desktop (copia o arquivo.x da pasta meuusuario para Desktop), -R # # serve pra copiar diretórios e seus sub-diretórios (-R = recursivamente)...</p><p># <span style="color: blue;">mv</span> - move ou renomeia um arquivo</p><p># <span style="color: blue;">rm</span> - deleta arquivos, ex.: rm /home/meusuario/arquivo.x (rm -rf, deleta recursivamente de maneira forçada, serve para diretórios)</p><p># <span style="color: blue;">rmdir</span> - remove diretórios (uso pouco esse, prefiro usar: rm -rf)</p><p># <span style="color: blue;">clear</span> - limpa a tela (uso pouco também)</p><p># <span style="color: blue;">exit</span> - sai do usuario logado, se não for root, sai do terminal.</p><p># <span style="color: blue;">df</span> - mostra o espaço usado na partição (df -H, mostra o espaço em GB, uso mais esse)</p><p># <span style="color: blue;">vim</span> - abre o vim (breve falaremos mais sobre esse editor, talvez a próxima parte deste curso)</p><p># <span style="color: blue;">find</span> - procura arquivos ou diretório, ex.: (find /home -name arquivo.x 2 &gt; /dev/null) a opção 2 /dev/null, vc joga para o vazio as mensagens de falta de permissão # para entrar naquele determinado diretório, ou seja, em /dev ficam os dispositivos do sistema o stdin é a entrada o stout é a saída (name - busca por nome, type - # # busca por tipo, size - busca pelo tamanho do arquivo, mtime - busca por data de modificação)...</p><p># <span style="color: blue;">last</span> - mostra os logs no sistema (last -a, uso muito, utilize o man  ou --help para mais informações)...</p><p># <span style="color: blue;">last</span>&nbsp;– Mostra todas informações referente as entradas (login) e saídas (logout) de usuários do sistema.</p><p># <span style="color: blue;">last -a</span>&nbsp;para exibir estas informações mostrando o nome da maquina de onde foi efetuado os logins.</p><p># <span style="color: blue;">last -d</span> - para exibir estas informações mostrando o&nbsp;endereço IP&nbsp;da maquina de onde foi efetuado os logins.</p><p># <span style="color: blue;">last reboot</span> -&nbsp;para exibir um registro de todas as reinicializações efetuadas no sistema.</p><p># <span style="color: blue;">lastlog</span>&nbsp;– Exibe informações referente ao último login de cada usuário cadastrado no sistema. Caso nenhum argumento seja passado, o comando&nbsp;lastlog&nbsp;exibe todas as # informações armazenadas no arquivo “/var/log/lastlog” de todos os usuários do sistema.</p><p># <span style="color: blue;">lastlog -u fulano</span> para exibir informações referentes apenas ao último login do usuário fulano.</p><p># <span style="color: blue;">lastlog -t 5</span> - &nbsp;para exibir a lista dos usuários que logaram no sistema nos últimos 5 dias informando o dia e a hora do último acesso de cada um desses usuários.</p><p># <span style="color: blue;">pwd</span> - mostra o diretório em que estamos.</p><p></p><p># <span style="color: blue;">chmod</span> - altera as permissões do arquivo , ex: chmod u+r, g+r, o+r arquivo, ex.: chmod 775 [arquivo ou diretório]</p><p>permissão de arquivos -&gt; r (read) ; w (write) ; x (executa).</p><p>u -&gt; dono</p><p>g -&gt; grupo</p><p>a -&gt; todos</p><p>sinais -&gt; + (acrescenta permissões) ; - (retira permissões) ; = (iguala permissões).</p><p>ele lista as permissões do arquivo : 0(nenhuma permissão=-);1(execução=x);2(gravação=w);3(execução e gravação=xw);4(leitura=r);5(leitura e execução=rx);</p><p>6(gravação e leitura=wr);7(execução gravação e leitura=rwx).</p><p>q - para sair do man (quit).</p><p></p><p># <span style="color: blue;">touch</span> - cria um arquivo, ex.: touch teste.txt (cria o arquivo teste.txt em branco)</p><p># <span style="color: blue;">echo</span>  - printa algo, se vc fier: echo Oi mundo &gt; teste.txt, ele coloca Oi mundo na primeira linha, se não existir o arquivo ele tb cria o arquivo.</p><p># <span style="color: blue;">cat</span>   -<arquivo .txt=".txt"> mostra o conteúdo do arquivo (utilize tb os comandos: more e less), se você usar: cat teste.txt &gt;&gt; teste2.txt (isso adicionará o conteúdo do teste.txt dentro do teste2.txt, sem apagá-lo, a partir da ultima linha do texte2.txt, se vc usar só '&gt;' em vez de '&gt;&gt;' vc altera o teste.txt para ser teste2.txt)</p><p># <span style="color: blue;">split</span> - inversos de cat, divide arquivos, ex.: split -b 1 teste2.txt novo , (dividi o arquivo teste2.txt em diversos arquivos de 1 byte, se tiver 10bytes serão 10 arquivo: novoa, novob, novoc...)</p><p># <span style="color: blue;">fdisk -l</span> - lista as partições do HD</p><p># <span style="color: blue;">mount</span> - monta um dispositivo ou partição, ex.: mount /dev/sda3 /mnt/pasta (monta a partição sda3 dentro da pasta /mnt/pasta)</p><p># <span style="color: blue;">umount</span> - desmonta um dispositivo ou partição, ex.: umount /mnt/pasta</p><p># head - visualiza as 10 primeiras linhas de um arquivo o (-n é usado para informar qnts linhas vc deseja ler, ex.: -n 20).</p><p># <span style="color: blue;">tail</span> arquivo.txt - inverso do head,lê um arquivo começando da ultima as 10 ultimas linhas(muito usado pra verificar logs).</p><p># <span style="color: blue;">ps</span> - lista os processo, ex.: ps -U marcos (lista os processos para o usuário marcos).</p><p># <span style="color: blue;">kill</span> - mata um processo</p><p></arquivo></b>{% endhighlight %}</p><p><b>+ comandos</b></p><p><b>{% highlight bash %}</p><p># <span style="color: blue;">killall</span> - mata todos os processos de tal aplicativo, ex.: killall firefox (mata o firefox, firefox-bin...)</p><p># <span style="color: blue;">pidof</span> - numero de processo de um PID ,exemplo: pidof httpd , retornará os PID do Apache</p><p># <span style="color: blue;">who</span> - mostra quem está logado na máquina(whoami , mostra quem eu sou).</p><p># <span style="color: blue;">free</span> - mostra a utilização da memória, a opção -m mostra a quantidade em Mb.</p><p></p><p># <span style="color: blue;">su</span> - troca ed usuário no terminal sem fazer logoff , ex: $ su root -&gt; deve-se colocar a senha(password) do usuario root.</p><p></p><p># <span style="color: blue;">pwd</span> - mostra em que diretório estamos</p><p></p><p># <span style="color: blue;">time</span> - mostra quanto tempo gasto para execução de um comando (time ls -l)</p><p></p><p># <span style="color: blue;">date</span> - mostra a data(SS MM DD) a hora (hh:mm:ss) a localidade e o ano.</p><p></p><p>&nbsp; date 0627002412010 - alterará a data para jun 27 00:24 2010 ,ou seja (MMDDhhmmAAAA)</p><p></p><p>MM=mês em dois dígitos;DD=dia em dois dígitos;hh=hora em dois digitos;mm=minutos em dois digitos;AAAA=ano em 4 dígitos.</p><p></p><p># <span style="color: blue;">cal</span> - para exibir o calendário (para exibir do ano inteiro deve-se colocar o anos na frente do comando, ex: cal 2010)</p><p></p><p># <span style="color: blue;">adduser</span> <nome_do_usuario_a_ser_criado> - criar novo usuario (2x Entre new Unix password:) é criada uma pasta em /etc/passwd/ ,as linhas tem enradas:</p><p></p><p>root:x:0:0:root:/bin/bash (significa nome do usuario:a senha ou token de senha(criptografada geralmente em /etc/shadow):userid:groupid:nome verdadeiro:diretorio e se é usuario do shell) caso retire a entrada, o usuario nao poderá logar, útil para criação de email.userid deve-se usar acima de 500 para nao confudir com os do sistema.</p><p></p><p># <span style="color: blue;">chown</span> - altera o dono do arquivo, ex: chown usuario.grupo arquivo.txt</p><p></p><p># <span style="color: blue;">shutdown</span> - desliga o pc num tempo pre-definido exibindo uma mensagem antes de desligar.</p><p></p><p># <span style="color: blue;">ln</span> - cria links, ex.: <span style="color: blue;">ln -s</span> /home/usuario/Documentos/ link (cria o link para a pasta Documentos, ln -s [diretório ou arquivo] link )</p><p></p><p># <span style="color: blue;">reboot</span> - reinicia o computador</p><p># <span style="color: blue;">uptime</span> - mostra quanto tempo já está logado no Linux</p><p># <span style="color: blue;">wc</span> [arquivo] - conta linhas,palavras e letras(nessa ordem) de um arquivo.</p><p># <span style="color: blue;">tar</span> - compacta (-cf Create Files)  e descompacta (-xf Xtract Files), ex.: tar -cf arquivo_a_ser_criado.tar [arquivo ou diretório]</p><p>[/nome_do_usuario_a_ser_criado]</nome_do_usuario_a_ser_criado>{% endhighlight %}</b></p><p><b></p><p></b></p><p><b>E por fim...</b></p><p>{% highlight bash %}<b></p><p># <span style="color: blue;">bash</span> - EXECUTA UM ARQUIVO Shell Script(pode -se usar também o '<span style="color: blue;">./</span>arquivo' ou <span style="color: blue;">sh</span> ).</b></p><p>{% endhighlight %}</p><p><b>Bom existem inúmeros outros comandos, se quiser saber mais, consulte esse <a href="http://books.google.com.br/books?id=ba4EJ9dfTt0C&amp;printsec=frontcover&amp;dq=shell+script&amp;hl=pt-BR&amp;ei=5FAfTb-iN4OclgeliImCDA&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=2&amp;ved=0CC0Q6AEwAQ#v=onepage&amp;q=shell%20script&amp;f=false" target="_blank"><span style="color: #274e13;">Livro On Line do Google Livros</span> <span style="color: blue;">CLASSIC SHELL SCRIPT</span></a>, foi o mais completo que eu vi até hoje, até a próxima parte do Curso, onde aprederemos os módulos básicos do Shell.</b></p><p></p><p><b>Para iniciarmos um script em Shell devemos ter a "Linha Mágica", assim chamada, é o identificador</b></p><p>do Interpretador, o Bash.</p><p>{% highlight bash %}#!/bin/bash{% endhighlight %}</p><p></p><p><b>Ao salvar o arquivo em shell(arquivo ou arquivo.sh) devemos dar a permissãod e execução:</b></p><p>{% highlight bash %}# chmod +x arquivo.sh{% endhighlight %}</p><p></p><p><b>Para rodar o arquivo pode-se usar(bash, sh ou ./):</b></p><p>{% highlight bash %}# bash arquivo.sh</p><p># sh arquivo.sh</p><p># ./arquivo.sh{% endhighlight %}</p><p></p><p><b>Criando variáveis:</b></p><p>{% highlight bash %}nome_da_variavel="valor da variável"</p><p>{% endhighlight %}</p><p></p><p><b>Variáveis de Ambiente:</b></p><p><b>As variáveis de ambiente são aquelas conhecidas pelos demais processos (programas em execução). Exemplos destas variáveis são: TERM,HOME, PATH, EDITOR, etc.</b></p><p><b>Para verificar todas as variáveis de ambiente basta digitarmos no terminal o comando:</b></p><p>{% highlight bash %}export -p{% endhighlight %}</p><p></p><p><b>Qualquer variável pode se tornar uma variável de ambiente. Para isto, ela deve ser "exportada", com o comando export:</b></p><p>{% highlight bash %}# export [variável]</p><p># export [svariável]=[valor]</p><p>{% endhighlight %}</p><p></p><p><b>Para visualizar todas as variáveis basta digitar no terminal:</b></p><p>{% highlight bash %}# set</p><p>ou </p><p># env{% endhighlight %}</p><p></p><p><b>Uma importante variável de ambiente é PATH que ajuda o shell a encontrar os comandos que o usuário executa. Todo comando executado é, na realidade, um arquivo. Estes arquivos são chamados executáveis e estão armazenados em vários diretórios como /bin ou /usr/bin. O valor da variável PATH é uma lista de diretórios em que o shell procura toda vez que executamos um comando cujo arquivo não é encontrado no diretório corrente. Assim, não precisamos alterar o diretório de trabalho todas vez que necessitamos executar um comando que se encontra em outro diretório. Basta acrescentar o diretório que contém tal comando à variável PATH. Os nomes dos diretórios na variável são separados pelo caractere dois-pontos (:).</b></p><p><b></p><p></b></p><p><b>Caso o usuário marcos queira adicionar um outro diretório, digamos /home/marcos/bin à variável PATH, deve proceder como mostrado a seguir:</b></p><p>{% highlight bash %}$ export PATH=$PATH:/home/marcos/bin   # adiciona o diretório</p><p>$ echo $PATH                         # verifica</p><p>/bin:/usr/bin:/usr/local/bin:/home/marcos/bin{% endhighlight %}</p><p></p><p><b>Existem também as variáveis especiais que são nativas do sistema:</b></p><p><table border="1"><thead><tr><td>Variável</td> <td>Descrição</td> </tr></thead> <tbody><tr> <td>$0</td> <td>Parâmetro número 0 (nome do comando ou função)</td> </tr><tr> <td>$1</td> <td>Parâmetro número 1 (da linha de comando ou função)</td> </tr><tr> <td>…</td> <td>Parâmetro número N …</td> </tr><tr> <td>$9</td> <td>Parâmetro número 9 (da linha de comando ou função)</td> </tr><tr> <td>${10}</td> <td>Parâmetro número 10 (da linha de comando ou função)</td> </tr><tr> <td>$#</td> <td>Número total de parâmetros da linha de comando ou função</td> </tr><tr> <td>$*</td> <td>Todos os parâmetros, como uma string única</td> </tr><tr> <td>$@</td> <td>Todos os parâmetros, como várias strings protegidas</td> </tr><tr> <td>$$</td> <td>Número PID do processo atual (do próprio script)</td> </tr><tr> <td>$!</td> <td>Número PID do último processo em segundo plano</td> </tr><tr> <td>$_</td> <td>Último argumento do último comando executado</td> </tr><tr> <td>$?</td> <td>Valor de retorno do último comando executado</td></tr></tbody></table></p><p><b>O if, ao contrário do que ocorre em muitas outras linguagens, testa o retorno de um comando, não uma expressão.</b></p><p><b></p><p></b></p><p><b>Por exemplo:</b></p><p></p><p>{% highlight bash %}if test 5 -lt 7</p><p>then</p><p>echo '5 é menor que 7'</p><p>fi{% endhighlight %}</p><p><b>Porém, é possível posicionar a expressão entre colchetes, de forma a tornar o if mais parecido com o que acontece em outras linguagens:</b></p><p></p><p>{% highlight bash %}if [ 5 -lt 7 ]</p><p>then</p><p>echo '5 é menor que 7'</p><p>fi{% endhighlight %}</p><p></p><p><b>O “-lt” significa “less than“, ou seja, “menor que“, equivalendo ao operador "&lt;".</b></p><p></p><p><b>Outros possíveis operadores são:</b></p><p><b></p><p></b></p><p><b>Comparação Numérica</b></p><p><b>-lt: É menor que (LessThan)</b></p><p><b>-gt: É maior que (GreaterThan)</b></p><p><b>-le: É menor igual (LessEqual)</b></p><p><b>-ge: É maior igual (GreaterEqual)</b></p><p><b>-eq: É igual (EQual)</b></p><p><b>-ne: É diferente (NotEqual)</b></p><p><b></p><p></b></p><p><b>Comparação de Strings</b></p><p><b>=: É igual</b></p><p><b>!=: É diferente</b></p><p><b>-n: É não nula (não vazia)</b></p><p><b>-z: É nula (vazia)</b></p><p><b></p><p></b></p><p><b>Operadores Lógicos</b></p><p><b>!: NÃO lógico (NOT)</b></p><p><b>-a: E lógico (AND)</b></p><p><b>-o: OU lógico (OR)</b></p><p><b></p><p></b></p><p><b>Testes em arquivos</b></p><p><b>-b: É um dispositivo de bloco</b></p><p><b>-c: É um dispositivo de caractere</b></p><p><b>-d: É um diretório</b></p><p><b>-e: O arquivo existe</b></p><p><b>-f: É um arquivo normal</b></p><p><b>-g: O bit SGID está ativado</b></p><p><b>-G: O grupo do arquivo é o do usuário atual</b></p><p><b>-k: O sticky-bit está ativado</b></p><p><b>-L: O arquivo é um link simbólico</b></p><p><b>-O: O dono do arquivo é o usuário atual</b></p><p><b>-p: O arquivo é um named pipe</b></p><p><b>-r: O arquivo tem permissão de leitura</b></p><p><b>-s: O tamanho do arquivo é maior que zero</b></p><p><b>-S: O arquivo é um socket</b></p><p><b>-t: O descritor de arquivos N é um terminal</b></p><p><b>-u: O bit SUID está ativado</b></p><p><b>-w: O arquivo tem permissão de escrita</b></p><p><b>-x: O arquivo tem permissão de execução</b></p><p><b>-nt: O arquivo é mais recente (NewerThan)</b></p><p><b>-ot: O arquivo é mais antigo (OlderThan)</b></p><p><b>-ef: O arquivo é o mesmo (EqualFile)</b></p><p><b></p><p></b></p><p><b>Utilizando o CASE:</b></p><p>{% highlight bash %}echo "Digite um número"</p><p>read x</p><p></p><p>case "$x" in </p><p>1)</p><p>echo "Você digitou o número 1"</p><p>;;</p><p>2)</p><p>echo "Você digitou o número 2"</p><p>;;</p><p>*)</p><p>echo "Você digitou outro número"</p><p>esac{% endhighlight %}</p><p></p><p><b>O loop FOR:</b></p><p>{% highlight bash %}for ((i = 0; i &lt; 10; i++) do     echo $i done{% endhighlight %}</p><p></p><p><b>O loop WHILE:</b></p><p>{% highlight bash %}i=0</p><p>while [ $i -lt 10 ]</p><p>do</p><p>echo $i</p><p>i=$((i+1))</p><p>done{% endhighlight %}</p><p></p><p><b>O BREAK:</b></p><p>{% highlight bash %}i=0</p><p>while true</p><p>do</p><p>if [ $i -ge 10 ]</p><p>then</p><p>break</p><p>fi</p><p>i=$((i+1))</p><p>done{% endhighlight %}</p><p></p><p><b>O comando continue para a execução da iteração corrente e vai para a próxima iteração, mesmo que haja mais comandos no bloco de repetição.</b></p><p><b></p><p></b></p><p><b>Entrada/Saída:</b></p><p><b></p><p></b></p><p><b>Existem três dispositivos principais, que sempre estão abertos, que merecem destaque:</b></p><p><b></p><p></b></p><p><b>stdin (standard input): entrada padrão. Corresponde, em geral, ao teclado;</b></p><p><b>stdout (standard output): saída padrão. Corresponde, em geral, à tela do terminal;</b></p><p><b>stderr (standard error): saída padrão de erros. Corresponde, em geral, à tela do terminal, também.</b></p><p><b></p><p></b></p><p><b>Esses três dispositivos estão em /dev e estão sempre disponíveis. Quem programa em C, sabe muito bem disso, pois já deve ter usado stdin, stdout e stderr junto com fprintf, fread, fwrite e semelhantes; esses três dispositivos comportam-se como arquivos comuns, sempre abertos e que não devem ser fechados.</b></p><p><b>Experimentem dar um cat em /dev/stdin para ver o que o que você digitar será repetido, entrada + saida.</b></p><p><b></p><p></b></p><p><b>Utilizando Pipelines:</b></p><p><b>Pipeline ou Pipe é um recurso do shell que nos permite conectar vários comandos usando um pipe, onde a saída do primeiro comando é enviada diretamente à entrada do segundo e assim por diante no caso de haver mais de dois comandos conectados por pipes.</b></p><p><b></p><p></b></p><p><b>No nosso caso, queremos enviar a saída do comando ls para a entrada do comando sort. O símbolo "|" (barra vertical) é usado para criar um pipe, ex.:</b></p><p>{% highlight bash %}# ls | sort -r {% endhighlight %}</p><p><b>É importante observar que o redirecionamento e o uso de pipes são características do shell e não dos comandos em si. É o shell quem provê a sintaxe dos símbolos "&lt;", "&gt;" e "|". Logo, se você criar um programa que utilize entrada de dados via stdin, poderá usar redirecionamento para especificar uma entrada para o seu programa.</b></p><p><b></p><p></b></p><p><b>Expansões:</b></p><p><b></p><p></b></p><p><b>Expansões são caracteres, ou uma sequência deles, que expressa outro significado. O intuito disso é facilitar e padronizar comandos.</b></p><p></p><p><i>~: path à home do usuário corrente</i></p><p><i>~user: path à home do usuário “user”</i></p><p></p><p><b>Definindo Funções</b></p><p><b></p><p></b></p><p><b>Sintaxe:</b></p><p>{% highlight bash %}function nome_da_funcao()</p><p>{</p><p>[comandos]</p><p>}</p><p>{% endhighlight %}</p><p><b>Para chamar a função:</b></p><p>{% highlight bash %}nome_da_funcao</p><p></p><p># caso haja parâmetros</p><p>nome_da_funcao param1 param2 ...{% endhighlight %}</p><p></p><p><b>Para retornar valor (status) numa função, usa-se o comando return.</b></p><p><b></p><p></b></p><p><b>Exemplo:</b></p><p></p><p>{% highlight bash %}#!/bin/bash</p><p></p><p>function retorna()</p><p>{</p><p>echo "sou um valor"</p><p>return 42</p><p>}</p><p></p><p>valor=$(retorna)</p><p>echo $?</p><p>echo $valor{% endhighlight %}</p><p></p><p><b>Expressões Regulares em Bash</b></p><p><b></p><p></b></p><p><b>Expressões regulares em shell podem ser usadas em comparações (if’s), por exemplo. Em if’s, usa-se o operador “=~” para realizar comparações usando ER’s:</b></p><p></p><p>{% highlight bash %}s="bash"</p><p>if [[ "$s" =~ ^b ]]</p><p>then</p><p>echo 'começa com b'</p><p>fi{% endhighlight %}</p><p></p><p><b>Expressões Matemáticas</b></p><p></p><p><b>O bash não trabalha com expressões matemáticas tão facilmente. Existe o comando “let”, que permite realizar expressões matemáticas, mas é mais comum se usar a sintaxe semelhante ao C, utilizando dois parênteses:</b></p><p></p><p>{% highlight bash %}$ a=$((1 + 1))</p><p>$ ((i++))</p><p>$ x=$((x*2))</p><p>...{% endhighlight %}</p><p></p><p><b>O Arquivo .bashrc</b></p><p><b></p><p></b></p><p><b>Na home dos usuários (~), é comum haver o arquivo .bashrc (o ponto no início indica que o arquivo é oculto). Esse arquivo é sempre executado quando se abre um shell. Nele, constam diversas configurações, como definição de variáveis de ambientes, definição de aliases etc. Você pode editar esse arquivo (ou criá-lo, caso não exista):</b></p><p></p><p>{% highlight bash %}# vim ~/.bashrc{% endhighlight %}</p><p></p><p><b>É possível usar outros editores, não apenas o vim.</b></p><p><b></p><p></b></p><p><b>Aliases (Apelidos)</b></p><p><b></p><p></b></p><p><b>Algumas vezes usamos comandos que necessitam de várias opções e argumentos. Para amenizar o trabalho de digitarmos repetidamente estes comandos o bash oferece um recurso chamado alias com o qual podemos definir sinônimos ou “apelidos” para um comando. Um alias pode ser definido na linha de comando da seguinte forma:</b></p><p></p><p><i>alias nome=comando</i></p><p></p><p><b>Observe que não pode haver espaços em branco antes ou depois do “=”.</b></p><p><b></p><p></b></p><p><b>Esta sintaxe indica que nome é um “alias” (apelido) para comando. Toda vez que digitarmos o comando “nome”, o bash o substituirá por “comando”.</b></p><p><b></p><p></b></p><p><b>Exemplo:</b></p><p></p><p>{% highlight bash %}# alias lf='ls -F'{% endhighlight %}</p><p></p><p><b>Isso fará o shell executar “ls -F” toda vez que usarmos “lf” na linha de comando. Ou seja, o que o alias faz na verdade é substituir a palavra “lf” por “ls -F”. Observe neste exemplo, existe um espaço em branco entre ls e -F. Sempre que houver espaços em branco na definição de um campo, todo o campo deve ser digitado entre aspas simples (‘) ou duplas (“).É possível definir aliases em seu .bashrc, para que eles estejam sempre disponíveis na sua sessão.</b></p><p></p><p><b><span style="color: #666666;">Fonte:</span></b> <a href="http://ogordo.com/curso-de-shell-script-modulo-1-scripts-shell-e-suas-estruturas/" style="color: blue;" target="_blank">O Gordo</a> e <a href="http://www.rberaldo.com.br/blog/curso-de-shell-script-modulo-1-scripts-shell-estruturas" style="color: blue;" target="_blank">rberaldo</a></p><p></p><p><b>Atalhos da linha de comando</b></p><p></p><p><table align="center" border="1"><tbody><tr><th>Atalho</th> <th>Descrição</th> <th>Tecla Similar</th> </tr><tr> <td>Ctrl+A</td> <td>Move o cursor para o início da linha</td> <td align="center">Home</td> </tr><tr> <td>Ctrl+B</td> <td>Move o cursor uma posição à esquerda</td> <td align="center">←</td> </tr><tr> <td>Ctrl+C</td> <td>Envia sinal EOF() para o sistema</td> <td></p><p></td> </tr><tr> <td>Ctrl+D</td> <td>Apaga um caractere à direita</td> <td align="center">Delete</td> </tr><tr> <td>Ctrl+E</td> <td>Move o cursor para o fim da linha</td> <td align="center">End</td> </tr><tr> <td>Ctrl+F</td> <td>Move o cursor uma posição à direita</td> <td align="center">→</td> </tr><tr> <td>Ctrl+H</td> <td>Apaga um caractere à esquerda</td> <td align="center">Backspace</td> </tr><tr> <td>Ctrl+I</td> <td>Completa arquivos e comandos</td> <td align="center">Tab</td> </tr><tr> <td>Ctrl+J</td> <td>Quebra a linha</td> <td align="center">Enter</td> </tr><tr> <td>Ctrl+K</td> <td>Recorta do cursor até o fim da linha</td> <td></p><p></td> </tr><tr> <td>Ctrl+L</td> <td>Limpa a tela (igual ao comando clear)</td> <td></p><p></td> </tr><tr> <td>Ctrl+N</td> <td>Próximo comando</td> <td></p><p></td> </tr><tr> <td>Ctrl+P</td> <td>Comando anterior</td> <td></p><p></td> </tr><tr> <td>Ctrl+Q</td> <td>Destrava a shell (veja Ctrl+S)</td> <td></p><p></td> </tr><tr> <td>Ctrl+R</td> <td>Procura no histórico de comandos</td> <td></p><p></td> </tr><tr> <td>Ctrl+S</td> <td>Trava a shell (veja Ctrl+Q)</td> <td></p><p></td> </tr><tr> <td>Ctrl+T</td> <td>Troca dois caracteres de lugar</td> <td></p><p></td> </tr><tr> <td>Ctrl+U</td> <td>Recorta a linha inteira</td> <td></p><p></td> </tr><tr> <td>Ctrl+V</td> <td>Insere caractere literal</td> <td></p><p></td> </tr><tr> <td>Ctrl+W</td> <td>Recorta a palavra à esquerda</td> <td></p><p></td> </tr><tr> <td>Ctrl+X</td> <td>Move o cursor para o início/fim da linha (2x)</td> <td align="center">Home/End</td> </tr><tr> <td>Ctrl+Y</td> <td>Cola o trecho recortado</td> <td></p><p></td></tr></tbody></table></p><p><b>Fonte: <a href="http://aurelio.net/shell/canivete/" style="color: blue;" target="_blank">Aurelio.net Canivete Suíço do Shell</a></b></p><p></p><p><b>Pra quem já conhece o blog, percebeu que foi reunido 3 posts nesse aqui, mas essa é a idéia, reforçar o aprendizado, segue os links:</b></p><p><b></p><p></b> <span style="color: blue;"><b><a href="http://marcospinguim.blogspot.com.br/2011/11/curso-de-shell-script-parte-1.html" target="_blank">Curso de Shell Script parte 1</a></b></span></p><p><span style="color: blue;"><b><a href="http://marcospinguim.blogspot.com.br/2011/11/curso-de-shell-script-parte-2.html" target="_blank">Curso de Shell Script parte 2</a></b></span></p><p><span style="color: blue;"><b><a href="http://marcospinguim.blogspot.com.br/2011/12/atalhos-da-linha-de-comando.html" target="_blank">Atalhos da linha de comando</a></b></span></p><p></p><p>

</p>
