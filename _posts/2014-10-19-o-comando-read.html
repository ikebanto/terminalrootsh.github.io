---
layout: post
title: O comando read
date: '2014-10-19T07:51:00.000-07:00'
author: Marcos Oliveira
tags:
- Shell Script
- Comandos
modified_time: '2014-10-19T07:51:25.605-07:00'
blogger_id: tag:blogger.com,1999:blog-2422865715758349944.post-6251799231929270495
blogger_orig_url: http://www.terminalroot.com.br/2014/10/o-comando-read.html
---

<h2></h2>Bem a partir de agora vamos aprender tudo sobre leitura, só não posso  ensinar a ler cartas e búzios porque se eu soubesse, estaria rico, num <i>pub</i> londrino tomando <i>scotch</i> e não em um boteco desses tomando chope. Mas vamos em frente.<br />Da última vez que nos encontramos aqui eu já dei uma palinha sobre o comando {% highlight bash %}read{% endhighlight %}. Para começarmos a sua analise mais detalhada. veja só isso:<br /><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ read var1 var2 var3<span style="color: white;"><br />Papo de Botequim</span><br />$ echo $var1<span style="color: white;"><br />Papo</span><br />$ echo $var2<span style="color: white;"><br />de</span><br />$ echo $var3<span style="color: white;"><br />Botequim</span><br />$ read var1 var2<span style="color: white;"><br />Papo de Botequim</span><br />$ echo $var1<span style="color: white;"><br />Papo</span><br />$ echo $var2<span style="color: white;"><br />de Botequim</span></div>Como você viu, o {% highlight bash %}read{% endhighlight %} recebe uma lista separada por  espaços em branco e coloca cada item desta lista em uma variável. Se a  quantidade de variáveis for menor que a quantidade de itens, a última  variável recebe o restante.<br />Eu disse lista separada por espaços em branco? Agora que você já conhece tudo sobre o {% highlight bash %}$IFS{% endhighlight %} (<kbd>I</kbd>nter <kbd>F</kbd>ield <kbd>S</kbd>eparator) que eu te apresentei quando falávamos do comando {% highlight bash %}for{% endhighlight %}, será que ainda acredita nisso? Vamos testar direto no <i>prompt</i>:<br /><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ oIFS=”$IFS”<br />$ IFS=:<br />$ read var1 var2 var3<span style="color: white;"><br />Papo de Botequim</span><br />$ echo $var1<span style="color: white;"><br />Papo de Botequim</span><br />$ echo $var2$ echo $var3<br />$ read var1 var2 var3<span style="color: white;"><br />Papo:de:Botequim</span><br />$ echo $var1<span style="color: white;"><br />Papo</span><br />$ echo $var2<span style="color: white;"><br />de</span><br />$ echo $var3<span style="color: white;"><br />Botequim</span><br />$ IFS=”$oIFS”</div>Viu, estava furado! O {% highlight bash %}read{% endhighlight %} lê uma lista, assim como o {% highlight bash %}for{% endhighlight %}, separada pelos caracteres da variável {% highlight bash %}$IFS{% endhighlight %}. Então veja como isso pode facilitar a sua vida:<br /><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ grep julio /etc/passwd<span style="color: white;"><br />julio:x:500:544:Julio C. Neves – 7070:/home/julio:/bin/bash</span><br />$ oIFS=”$IFS”    #  Salvando IFS<br />$ IFS=:<br />$ grep julio /etc/passwd | read lname lixo uid gid coment home shell<br />$ echo -e “$lnamen$uidn$gidn$comentn$homen$shell”<span style="color: white;"><br />julio<br />500<br />544<br />Julio C. Neves – 7070<br />/home/julio<br />/bin/bash</span><br />$ IFS=”$oIFS”   #  Restaurando IFS</div>Como você viu, a saída do {% highlight bash %}grep{% endhighlight %} foi redirecionada para o comando {% highlight bash %}read{% endhighlight %} que leu todos os campos de uma só tacada. A opção {% highlight bash %}-e{% endhighlight %} do {% highlight bash %}echo{% endhighlight %} foi usada para que o {% highlight bash %}n{% endhighlight %} fosse entendido como um salto de linha (<i>new line</i>), e não como um literal.<br />Sob o Bash existem diversas opções do {% highlight bash %}read{% endhighlight %} que servem para facilitar a sua vida. Veja a tabela a seguir:<br /><table border="0" cellpadding="2" cellspacing="1" class="twikiTable"><tbody><tr><th align="center" bgcolor="#000000" class="twikiFirstCol" colspan="2"><b><span style="color: white;">Opções do comando read no Bash</span></b></th></tr><tr><td bgcolor="#ffffff" class="twikiFirstCol"><b>Opção</b></td><td bgcolor="#ffffff"><b>Ação</b></td></tr><tr><td align="center" bgcolor="#ffffff" class="twikiFirstCol">{% highlight bash %}-p prompt{% endhighlight %}</td><td bgcolor="#ffffff">Escreve o {% highlight bash %}prompt{% endhighlight %} antes de fazer a leitura</td></tr><tr><td align="center" bgcolor="#ffffff" class="twikiFirstCol">{% highlight bash %}-n num{% endhighlight %}</td><td bgcolor="#ffffff">Lê até {% highlight bash %}num{% endhighlight %} caracteres</td></tr><tr><td align="center" bgcolor="#ffffff" class="twikiFirstCol">{% highlight bash %}-t seg{% endhighlight %}</td><td bgcolor="#ffffff">Espera {% highlight bash %}seg{% endhighlight %} segundos para que a leitura seja concluída</td></tr><tr><td align="center" bgcolor="#ffffff" class="twikiFirstCol">{% highlight bash %}-s{% endhighlight %}</td><td bgcolor="#ffffff">O que está sendo teclado não aparece na tela</td></tr></tbody></table>E agora direto aos exemplos curtos para demonstrar estas opções.<br />Para ler um campo “Matrícula”:<br /><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ echo -n “Matricula: “; read Mat # -n nao salta linha<span style="color: white;"><br />Matricula: 12345</span><br />$ echo $Mat<span style="color: white;"><br />12345</span></div>Ou simplificando com a opção {% highlight bash %}-p{% endhighlight %}:<br /><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ read -p “Matricula: ” Mat<span style="color: white;"><br />Matricula: 12345</span><br />$ echo $Mat<span style="color: white;"><br />12345</span></div>Para ler uma determinada quantidade de caracteres:<br /><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ read -n5 -p”CEP: ” Num ; read -n3 -p- Compl<span style="color: white;"><br />CEP: 12345-678</span>$<br />$ echo $Num<span style="color: white;"><br />12345</span><br />$ echo $Compl<span style="color: white;"><br />678</span></div>Neste exemplo fizemos dois {% highlight bash %}read{% endhighlight %}: um para a primeira parte do CEP e outra para o seu complemento, deste modo formatando a entrada de dados. O cifrão ({% highlight bash %}${% endhighlight %}) após o último algarismo teclado, é porque o {% highlight bash %}read{% endhighlight %} não tem o <i>new-line</i> implícito por <i>default</i> como o tem o {% highlight bash %}echo{% endhighlight %}.<br />Para ler que até um determinado tempo se esgote (conhecido como <i>time out</i>):<br /><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ read -t2 -p “Digite seu nome completo: ” Nom || echo ‘Eta moleza!’<span style="color: white;"><br />Digite seu nome completo: JEta moleza!</span><br />$ echo $Nom$</div>Obviamente isto foi uma brincadeira, pois só tinha 3 segundos para digitar o meu nome completo e só me deu tempo de teclar um {% highlight bash %}J{% endhighlight %} (aquele colado no {% highlight bash %}Eta{% endhighlight %}), mas serviu para mostrar duas coisas:<br /><ol><li> O comando após o par de barras verticais ({% highlight bash %}||{% endhighlight %}) (o ou lógico, lembra-se?) será executado caso a digitação não tenha sido concluída no tempo estipulado;</li><li> A variável {% highlight bash %}Nom{% endhighlight %} permaneceu vazia. Ela será valorada somente quando o {% highlight bash %}&lt;ENTER&gt;{% endhighlight %} for teclado.</li></ol>Para ler um dado sem ser exibido na tela:<br /><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ read -sp “Senha: “<span style="color: white;"><br />Senha: </span>$ echo $REPLY<span style="color: white;"><br />segredo <span class="wp-smiley wp-emoji wp-emoji-smile" title=":)">:)</span></span></div>Aproveitei um erro para mostrar um macete. Quando escrevi a primeira  linha, esqueci de colocar o nome da variável que iria receber a senha, e  só notei quando ia listar o seu valor. Felizmente a variável {% highlight bash %}$REPLY{% endhighlight %} do Bash, possui a última cadeia lida e me aproveitei disso para não perder a viagem. Teste você mesmo o que acabei de fazer.<br />Mas o exemplo que dei, era para mostrar que a opção {% highlight bash %}-s{% endhighlight %} impede o que está sendo teclado de ir para a tela. Como no exemplo anterior, a falta do <i>new-line</i> fez com que o <i>prompt</i> de comando ({% highlight bash %}${% endhighlight %}) permanecesse na mesma linha.<br />Bem, agora que sabemos ler da tela vejamos como se lê os dados dos arquivos.<br /><h3><a href="https://www.blogger.com/null" name="Vamos_ler_arquivos" title="Vamos_ler_arquivos"></a><a href="https://www.blogger.com/null" name="Vamos_ler_arquivos_" title="Vamos_ler_arquivos_"></a> Vamos ler arquivos?</h3>Como eu já havia lhe dito, e você deve se lembrar, o {% highlight bash %}while{% endhighlight %} testa um comando e executa um bloco de instruções enquanto este comando  for bem sucedido. Ora quando você está lendo um arquivo que lhe dá  permissão de leitura, o {% highlight bash %}read{% endhighlight %} só será mal sucedido quando alcançar o {% highlight bash %}EOF{% endhighlight %} (<i>end of file</i>), desta forma podemos ler um arquivo de duas maneiras:<br />1 – Redirecionando a entrada do arquivo para o bloco do {% highlight bash %}while{% endhighlight %} assim:<br /><pre>    while read Linha<br />    do<br />        echo $Linha<br />    done &lt; arquivo</pre>2 – Redirecionando a saída de um {% highlight bash %}cat{% endhighlight %} para o {% highlight bash %}while{% endhighlight %}, da seguinte maneira:<br /><pre>    cat arquivo |<br />    while read Linha<br />    do<br />        echo $Linha<br />    done</pre>Cada um dos processos tem suas vantagens e desvantagens:<br />Vantagens do primeiro processo:<br /><ul><li> É mais rápido;</li><li> Não necessita de um <i>subshell</i> para assisti-lo;</li></ul>Desvantagem do primeiro processo:<br /><ul><li> Em um bloco de instruções grande, o redirecionamento fica pouco visível o que por vezes prejudica a vizualização do código;</li></ul>Vantagem do segundo processo:<br /><ul><li> Como o nome do arquivo está antes do {% highlight bash %}while{% endhighlight %}, é mais fácil a vizualização do código.</li></ul>Desvantagens do segundo processo:<br /><ul><li> O <i>Pipe</i> ({% highlight bash %}|{% endhighlight %}) chama um <i>subshell</i> para interpretá-lo, tornando o processo mais lento, pesado e por vezes problemático (veja o exemplo a seguir).</li></ul>Para ilustrar o que foi dito, veja estes exemplos a seguir:<br /><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ cat <span class="skimlinks-unlinked">readpipe.sh</span><span style="color: white;"><br />#!/bin/bash<br /># <span class="skimlinks-unlinked">readpipe.sh</span><br /># Exemplo de read passando arquivo por pipe.<br /></span><br /><span style="color: white;">Ultimo=”(vazio)”<br />cat $0 | # Passando o arq. do script ($0) p/ while<br />while read Linha<br />do<br />Ultimo=”$Linha”<br />echo “-$Ultimo-“<br />done<br />echo “Acabou, Último=:$Ultimo:”</span></div>Vamos ver sua execução:<br /><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ <span class="skimlinks-unlinked">readpipe.sh</span><span style="color: white;"><br />-#!/bin/bash-<br />-# <span class="skimlinks-unlinked">readpipe.sh</span>-<br />-# Exemplo de read passando arquivo por pipe.-<br />–<br />-Ultimo=”(vazio)”-<br />-cat $0 | # Passando o arq. do script ($0) p/ while-<br />-while read Linha-<br />-do-<br />-Ultimo=”$Linha”-<br />-echo “-$Ultimo-“-<br />-done-<br />-echo “Acabou, Último=:$Ultimo:”-<br />Acabou, Último=:(vazio):</span></div>Como você viu, o <i>script</i> lista todas as suas próprias linhas com um sinal de menos ({% highlight bash %}-{% endhighlight %}) antes e outro depois de cada, e no final exibe o conteúdo da variável {% highlight bash %}$Ultimo{% endhighlight %}. Repare no entanto que o conteúdo desta variável permanece como {% highlight bash %}(vazio){% endhighlight %}.<br />- Ué será que a variável não foi atualizada?<br />- Foi, e isso pode ser comprovado porque a linha {% highlight bash %}echo "-$Ultimo-"{% endhighlight %} lista corretamente as linhas.<br />- Então porque isso aconteceu?<br />- Por que como eu disse, o bloco de instruções redirecionado pelo <i>pipe</i> ({% highlight bash %}|{% endhighlight %}) é executado em um <i>subshell</i> e lá as variáveis são atualizadas. Quando este <i>subshell</i> termina, as atualizações das variáveis vão para os píncaros do inferno  junto com ele. Repare que vou fazer uma pequena mudança nele, passando o  arquivo por redirecionamento de entrada (&lt;) e as coisas passarão a  funcionar na mais perfeita ordem:<br /><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ cat <span class="skimlinks-unlinked">redirread.sh</span><span style="color: white;"><br />#!/bin/bash<br /># <span class="skimlinks-unlinked">redirread.sh</span><br /># Exemplo de read passando arquivo por pipe.<br /></span><br /><span style="color: white;">Ultimo=”(vazio)”<br />while read Linha<br />do<br />Ultimo=”$Linha”<br />echo “-$Ultimo-“<br />done &lt; $0 # Passando o arq. do script ($0) p/ while<br />echo “Acabou, Último=:$Ultimo:”</span></div>E veja a sua perfeita execução:<br /><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ <span class="skimlinks-unlinked">redirread.sh</span><span style="color: white;"><br />-#!/bin/bash-<br />-# <span class="skimlinks-unlinked">redirread.sh</span>-<br />-# Exemplo de read passando arquivo por pipe.-<br />–<br />-Ultimo=”(vazio)”-<br />-while read Linha-<br />-do-<br />-Ultimo=”$Linha”-<br />-echo “-$Ultimo-“-<br />-done &lt; $0 # Passando o arq. do script ($0) p/ while-<br />-echo “Acabou, Último=:$Ultimo:”-<br />Acabou, Último=:echo “Acabou, Último=:$Ultimo:”:</span></div>Bem amigos da Rede <i>Shell</i>, para finalizar o comando {% highlight bash %}read{% endhighlight %} só falta mais um pequeno e importante macete que vou mostrar utilizando  um exemplo prático. Suponha que você queira listar na tela um arquivo e  a cada dez registros esta listagem pararia para que o operador pudesse  ler o conteúdo da tela e ela só voltasse a rolar (<i>scroll</i>) após o  operador digitar qualquer tecla. Para não gastar papel (da Linux  Magazine) pra chuchu, vou fazer esta listagem na horizontal e o meu  arquivo ({% highlight bash %}numeros{% endhighlight %}), tem 30 registros somente com números seqüênciais. Veja:<br /><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ seq 30 | xargs -i echo lin {} &gt; numeros   #  Criando arquivo numeros<br />$ paste -sd':’ numeros                      #  Este paste é para exibir o conteúdo sem ser um<br />#+ por linha, usando dois-pontos como separador<span style="color: white;"><br />lin 1:lin 2:lin 3:lin 4:lin 5:lin 6:lin 7:lin 8:lin 9:lin 10:lin 11:lin 12:lin 13:lin 14:lin 15:l<br />in 16:lin 17:lin 18:lin 19:lin 20:lin 21:lin 22:lin 23:lin 24:lin 25:lin 26:lin 27:lin 28:lin 29:<br />lin 30</span><br />$ cat 10porpag.sh<span style="color: white;"><br />#!/bin/bash<br /># Prg de teste para escrever<br /># 10 linhas e parar para ler<br /># Versão 1<br /></span><br /><span style="color: white;">while read Num<br />do<br />let ContLin++           # Contando…<br />echo -n “$Num ”         # -n para nao saltar linha<br />((ContLin % 10)) &gt; /dev/null || read<br />done &lt; numeros</span></div>Na tentativa de fazer um programa genérico criamos a variável {% highlight bash %}$ContLin{% endhighlight %} (por que na vida real, os registros não são somente números seqüenciais) e parávamos para ler quando o resto da divisão por {% highlight bash %}10{% endhighlight %} fosse zero (mandando a saída para {% highlight bash %}/dev/null{% endhighlight %} de forma a não aparecer na tela, sujando-a). Porém, quando fui executar deu a seguinte zebra:<br /><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ 10porpag.sh<span style="color: white;"><br />lin 1 lin 2 lin 3 lin 4 lin 5 lin 6 lin 7 lin 8 lin 9 lin 10 lin 12 lin 13 lin 14 lin 15 lin 16 l<br />in 17 lin 18 lin 19 lin 20 lin 21 lin 23 lin 24 lin 25 lin 26 lin 27 lin 28 lin 29 lin 30 </span>$</div>Repare que faltou a linha {% highlight bash %}lin 11{% endhighlight %} e a listagem não parou no {% highlight bash %}read{% endhighlight %}. O que houve foi que toda a entrada do <i>loop</i> estava redirecionada do arquivo {% highlight bash %}numeros{% endhighlight %} e desta forma, a leitura foi feita em cima deste arquivo, desta forma perdendo a {% highlight bash %}lin 11{% endhighlight %} (e também a {% highlight bash %}lin 22{% endhighlight %} ou qualquer linha múltipla de 11).<br />Vamos mostrar então como deveria ficar para funcionar a contento:<br /><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ cat 10porpag.sh<span style="color: white;"><br />#!/bin/bash<br /># Prg de teste para escrever<br /># 10 linhas e parar para ler<br /># Versão 2<br /></span><br /><span style="color: white;">while read Num<br />do<br />let ContLin++           # Contando…<br />echo -n “$Num ”         # -n para nao saltar linha<br />((ContLin % 10)) &gt; /dev/null || read &lt; /dev/tty<br />done &lt; numeros</span></div>Observe que agora a entrada do {% highlight bash %}read{% endhighlight %} foi redirecionada por {% highlight bash %}/dev/tty{% endhighlight %},  que nada mais é senão o terminal corrente, explicitando desta forma que  aquela leitura seria feita do teclado e não de numeros. É bom realçar  que isto não acontece somente quando usamos o redirecionamento de  entrada, se houvéssemos usado o redirecionamento via <i>pipe</i> ({% highlight bash %}|{% endhighlight %}), o mesmo teria ocorrido.<br />Veja agora a sua execução:<br /><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ 10porpag.sh<span style="color: white;"><br />lin 1 lin 2 lin 3 lin 4 lin 5 lin 6 lin 7 lin 8 lin 9 lin 10<br />lin 11 lin 12 lin 13 lin 14 lin 15 lin 16 lin 17 lin 18 lin 19 lin 20<br />lin 21 lin 22 lin 23 lin 24 lin 25 lin 26 lin 27 lin 28 lin 29 lin 30</span></div>Isto está quase bom mas falta um pouco para ficar excelente. Vamos  melhorar um pouco o exemplo para que você o reproduza e teste (mas antes  de testar aumente o número de registros de {% highlight bash %}numeros{% endhighlight %} ou reduza o tamanho da tela, para que haja quebra).<br /><div style="background: #000000 none no-repeat scroll right top; border: 1px none; color: yellow; font-family: Courier,'Courier New','Lucida Console','Bitstream Vera Sans Mono',Monaco,monospace; font-size: 100%; line-height: 1em; margin: 1em 0.5em; overflow: auto; padding: 1.5em 1em; white-space: pre;">$ cat 10porpag.sh<span style="color: white;"><br />#!/bin/bash<br /># Prg de teste para escrever<br /># 10 linhas e parar para ler<br /># Versão 3<br /></span><br /><span style="color: white;">clear<br />while read Num<br />do<br />((ContLin++))                           # Contando…<br />echo “$Num”<br />((ContLin % (`tput lines` – 3))) ||<br />{<br />read -n1 -p”Tecle Algo ” &lt; /dev/tty # para ler qq caractere<br />clear                               # limpa a tela apos leitura<br />}<br />done &lt; numeros</span></div>A mudança substancial feita neste exemplo é com relação à quebra de  página, já que ela é feita a cada quantidade-de-linhas-da-tela ({% highlight bash %}tput lines{% endhighlight %}) menos ({% highlight bash %}-{% endhighlight %}) {% highlight bash %}3{% endhighlight %}, isto é, se a tela tem 25 linha, listará 22 registros e parará para leitura. No comando {% highlight bash %}read{% endhighlight %} também foi feita uma alteração, inserido um {% highlight bash %}-n1{% endhighlight %} para ler somente um caractere sem ser necessariamente um {% highlight bash %}&lt;ENTER&gt;{% endhighlight %} e a opção {% highlight bash %}-p{% endhighlight %} para dar a mensagem.<br />- Bem meu amigo, por hoje é só porque acho que você já está de saco cheio…<br />- Num tô não, pode continuar…<br />- Se você não estiver eu estou… Mas já que você está tão empolgado  com o Shell, vou te deixar um exercício de apredizagem para você  melhorar a sua CDteca que é bastante simples. Reescreva o seu programa  que cadastra CDs para montar toda a tela com um único {% highlight bash %}echo{% endhighlight %} e depois vá posicionando à frente de cada campo para receber os valores que serão teclados pelo operador.<br />Vou aproveitar também para mandar o meu jabá: diga para os amigos que  quem estiver afim de fazer um curso porreta de programação em <i>Shell</i> que mande um e-mail para a nossa <a href="mailto:treinamentos@festivalsoftwarelivre.org?Subject=Curso%20de%20Shell%20com%20Julio%20Neves">gerencia de treinamento</a> para informar-se.<br />Qualquer dúvida ou falta de companhia para um chope ou até para falar mal dos políticos é só mandar um e-mail para <a href="mailto:julioneves@openoffice.org?Subject=D%C3%BAvidas%20Papo%20de%20Botequim">mim</a>.<br />Valeu!<br /><br />Via: http://jneves.wordpress.com