---
layout: post
title: Curso de Shell Script parte 2
date: '2015-01-02T03:56:00.002-08:00'
description: Curso de Shell Script parte 2
main-class: 'bash'
color: '#c2003a'
author: Marcos Oliveira
tags:
- Shell Script
modified_time: '2015-01-02T03:56:10.648-08:00'
thumbnail: http://1.bp.blogspot.com/-cYx3LMXO5Yc/VKaGxVIInNI/AAAAAAAABHo/jUGLHNh71pE/s72-c/icon175x175.png
twitter_text: Curso de Shell Script parte 2
introduction: Curso de Shell Script parte 2
---

<div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-cYx3LMXO5Yc/VKaGxVIInNI/AAAAAAAABHo/jUGLHNh71pE/s1600/icon175x175.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-cYx3LMXO5Yc/VKaGxVIInNI/AAAAAAAABHo/jUGLHNh71pE/s1600/icon175x175.png" /></a></div><b>Para iniciarmos um script em Shell devemos ter a "Linha Mágica", assim chamada, é o identificador</b><br />do Interpretador, o Bash.<br />{% highlight bash %}#!/bin/bash{% endhighlight %}<br /><br /><b>Ao salvar o arquivo em shell(arquivo ou arquivo.sh) devemos dar a permissãod e execução:</b><br />{% highlight bash %}# chmod +x arquivo.sh{% endhighlight %}<br /><br /><b>Para rodar o arquivo pode-se usar(bash, sh ou ./):</b><br />{% highlight bash %}# bash arquivo.sh<br /># sh arquivo.sh<br /># ./arquivo.sh{% endhighlight %}<br /><br /><b>Criando variáveis:</b><br />{% highlight bash %}nome_da_variavel="valor da variável"{% endhighlight %}<br /><br /><b>Variáveis de Ambiente:</b><br /><b>As variáveis de ambiente são aquelas conhecidas pelos demais processos (programas em execução). Exemplos destas variáveis são: TERM,HOME, PATH, EDITOR, etc.</b><br /><b>Para verificar todas as variáveis de ambiente basta digitarmos no terminal o comando:</b><br />{% highlight bash %}export -p{% endhighlight %}<br /><br /><b>Qualquer variável pode se tornar uma variável de ambiente. Para isto, ela deve ser "exportada", com o comando export:</b><br />{% highlight bash %}# export [variável]<br /># export [svariável]=[valor]{% endhighlight %}<br /><br /><b>Para visualizar todas as variáveis basta digitar no terminal:</b><br />{% highlight bash %}# set<br />ou <br /># env{% endhighlight %}<br /><br /><b>Uma importante variável de ambiente é PATH que ajuda o shell a encontrar os comandos que o usuário executa. Todo comando executado é, na realidade, um arquivo. Estes arquivos são chamados executáveis e estão armazenados em vários diretórios como /bin ou /usr/bin. O valor da variável PATH é uma lista de diretórios em que o shell procura toda vez que executamos um comando cujo arquivo não é encontrado no diretório corrente. Assim, não precisamos alterar o diretório de trabalho todas vez que necessitamos executar um comando que se encontra em outro diretório. Basta acrescentar o diretório que contém tal comando à variável PATH. Os nomes dos diretórios na variável são separados pelo caractere dois-pontos (:).</b><br /><b><br /></b><b>Caso o usuário marcos queira adicionar um outro diretório, digamos /home/marcos/bin à variável PATH, deve proceder como mostrado a seguir:</b><br />{% highlight bash %}$ export PATH=$PATH:/home/marcos/bin   # adiciona o diretório<br />$ echo $PATH                         # verifica<br />/bin:/usr/bin:/usr/local/bin:/home/marcos/bin{% endhighlight %}<br /><br /><b>Existem também as variáveis especiais que são nativas do sistema:</b><br /><table border="1"><thead><tr><td>Variável</td> <td>Descrição</td> </tr></thead> <tbody><tr> <td>$0</td> <td>Parâmetro número 0 (nome do comando ou função)</td> </tr><tr> <td>$1</td> <td>Parâmetro número 1 (da linha de comando ou função)</td> </tr><tr> <td>…</td> <td>Parâmetro número N …</td> </tr><tr> <td>$9</td> <td>Parâmetro número 9 (da linha de comando ou função)</td> </tr><tr> <td>${10}</td> <td>Parâmetro número 10 (da linha de comando ou função)</td> </tr><tr> <td>$#</td> <td>Número total de parâmetros da linha de comando ou função</td> </tr><tr> <td>$*</td> <td>Todos os parâmetros, como uma string única</td> </tr><tr> <td>$@</td> <td>Todos os parâmetros, como várias strings protegidas</td> </tr><tr> <td>$$</td> <td>Número PID do processo atual (do próprio script)</td> </tr><tr> <td>$!</td> <td>Número PID do último processo em segundo plano</td> </tr><tr> <td>$_</td> <td>Último argumento do último comando executado</td> </tr><tr> <td>$?</td> <td>Valor de retorno do último comando executado</td></tr></tbody></table><br /><b>O if, ao contrário do que ocorre em muitas outras linguagens, testa o retorno de um comando, não uma expressão.</b><br /><b><br /></b><b>Por exemplo:</b><br /><br />{% highlight bash %}if test 5 -lt 7<br />then<br />echo '5 é menor que 7'<br />fi{% endhighlight %}<br /><b>Porém, é possível posicionar a expressão entre colchetes, de forma a tornar o if mais parecido com o que acontece em outras linguagens:</b><br /><br />{% highlight bash %}if [ 5 -lt 7 ]<br />then<br />echo '5 é menor que 7'<br />fi{% endhighlight %}<br /><br /><b>O “-lt” significa “less than“, ou seja, “menor que“, equivalendo ao operador "&lt;".</b><br /><br /><b>Outros possíveis operadores são:</b><br /><b><br /></b><b>Comparação Numérica</b><br /><b>-lt: É menor que (LessThan)</b><br /><b>-gt: É maior que (GreaterThan)</b><br /><b>-le: É menor igual (LessEqual)</b><br /><b>-ge: É maior igual (GreaterEqual)</b><br /><b>-eq: É igual (EQual)</b><br /><b>-ne: É diferente (NotEqual)</b><br /><b><br /></b><b>Comparação de Strings</b><br /><b>=: É igual</b><br /><b>!=: É diferente</b><br /><b>-n: É não nula (não vazia)</b><br /><b>-z: É nula (vazia)</b><br /><b><br /></b><b>Operadores Lógicos</b><br /><b>!: NÃO lógico (NOT)</b><br /><b>-a: E lógico (AND)</b><br /><b>-o: OU lógico (OR)</b><br /><b><br /></b><b>Testes em arquivos</b><br /><b>-b: É um dispositivo de bloco</b><br /><b>-c: É um dispositivo de caractere</b><br /><b>-d: É um diretório</b><br /><b>-e: O arquivo existe</b><br /><b>-f: É um arquivo normal</b><br /><b>-g: O bit SGID está ativado</b><br /><b>-G: O grupo do arquivo é o do usuário atual</b><br /><b>-k: O sticky-bit está ativado</b><br /><b>-L: O arquivo é um link simbólico</b><br /><b>-O: O dono do arquivo é o usuário atual</b><br /><b>-p: O arquivo é um named pipe</b><br /><b>-r: O arquivo tem permissão de leitura</b><br /><b>-s: O tamanho do arquivo é maior que zero</b><br /><b>-S: O arquivo é um socket</b><br /><b>-t: O descritor de arquivos N é um terminal</b><br /><b>-u: O bit SUID está ativado</b><br /><b>-w: O arquivo tem permissão de escrita</b><br /><b>-x: O arquivo tem permissão de execução</b><br /><b>-nt: O arquivo é mais recente (NewerThan)</b><br /><b>-ot: O arquivo é mais antigo (OlderThan)</b><br /><b>-ef: O arquivo é o mesmo (EqualFile)</b><br /><b><br /></b><b>Utilizando o CASE:</b><br />{% highlight bash %}echo "Digite um número"<br />read x<br /><br />case "$x" in <br />1)<br />echo "Você digitou o número 1"<br />;;<br />2)<br />echo "Você digitou o número 2"<br />;;<br />*)<br />echo "Você digitou outro número"<br />esac{% endhighlight %}<br /><br /><b>O loop FOR:</b><br />{% highlight bash %}for ((i = 0; i &lt; 10; i++) do     echo $i done{% endhighlight %}<br /><br /><b>O loop WHILE:</b><br />{% highlight bash %}i=0<br />while [ $i -lt 10 ]<br />do<br />echo $i<br />i=$((i+1))<br />done{% endhighlight %}<br /><br /><b>O BREAK:</b><br />{% highlight bash %}i=0<br />while true<br />do<br />if [ $i -ge 10 ]<br />then<br />break<br />fi<br />i=$((i+1))<br />done{% endhighlight %}<br /><br /><b>O comando continue para a execução da iteração corrente e vai para a próxima iteração, mesmo que haja mais comandos no bloco de repetição.</b><br /><b><br /></b><b>Entrada/Saída:</b><br /><b><br /></b><b>Existem três dispositivos principais, que sempre estão abertos, que merecem destaque:</b><br /><b><br /></b><b>stdin (standard input): entrada padrão. Corresponde, em geral, ao teclado;</b><br /><b>stdout (standard output): saída padrão. Corresponde, em geral, à tela do terminal;</b><br /><b>stderr (standard error): saída padrão de erros. Corresponde, em geral, à tela do terminal, também.</b><br /><b><br /></b><b>Esses três dispositivos estão em /dev e estão sempre disponíveis. Quem programa em C, sabe muito bem disso, pois já deve ter usado stdin, stdout e stderr junto com fprintf, fread, fwrite e semelhantes; esses três dispositivos comportam-se como arquivos comuns, sempre abertos e que não devem ser fechados.</b><br /><b>Experimentem dar um cat em /dev/stdin para ver o que o que você digitar será repetido, entrada + saida.</b><br /><b><br /></b><b>Utilizando Pipelines:</b><br /><b>Pipeline ou Pipe é um recurso do shell que nos permite conectar vários comandos usando um pipe, onde a saída do primeiro comando é enviada diretamente à entrada do segundo e assim por diante no caso de haver mais de dois comandos conectados por pipes.</b><br /><b><br /></b><b>No nosso caso, queremos enviar a saída do comando ls para a entrada do comando sort. O símbolo "|" (barra vertical) é usado para criar um pipe, ex.:</b><br />{% highlight bash %}# ls | sort -r {% endhighlight %}<br /><b>É importante observar que o redirecionamento e o uso de pipes são características do shell e não dos comandos em si. É o shell quem provê a sintaxe dos símbolos "&lt;", "&gt;" e "|". Logo, se você criar um programa que utilize entrada de dados via stdin, poderá usar redirecionamento para especificar uma entrada para o seu programa.</b><br /><b><br /></b><b>Expansões:</b><br /><b><br /></b><b>Expansões são caracteres, ou uma sequência deles, que expressa outro significado. O intuito disso é facilitar e padronizar comandos.</b><br /><br /><i>~: path à home do usuário corrente</i><br /><i>~user: path à home do usuário “user”</i><br /><br /><b>Definindo Funções</b><br /><b><br /></b><b>Sintaxe:</b><br />{% highlight bash %}function nome_da_funcao()<br />{<br />[comandos]<br />}{% endhighlight %}<br /><b>Para chamar a função:</b><br />{% highlight bash %}nome_da_funcao<br /><br /># caso haja parâmetros<br />nome_da_funcao param1 param2 ...{% endhighlight %}<br /><br /><b>Para retornar valor (status) numa função, usa-se o comando return.</b><br /><b><br /></b><b>Exemplo:</b><br /><br />{% highlight bash %}#!/bin/bash<br /><br />function retorna()<br />{<br />echo "sou um valor"<br />return 42<br />}<br /><br />valor=$(retorna)<br />echo $?<br />echo $valor{% endhighlight %}<br /><br /><b>Expressões Regulares em Bash</b><br /><b><br /></b><b>Expressões regulares em shell podem ser usadas em comparações (if’s), por exemplo. Em if’s, usa-se o operador “=~” para realizar comparações usando ER’s:</b><br /><br />{% highlight bash %}s="bash"<br />if [[ "$s" =~ ^b ]]<br />then<br />echo 'começa com b'<br />fi{% endhighlight %}<br /><br /><b>Expressões Matemáticas</b><br /><br /><b>O bash não trabalha com expressões matemáticas tão facilmente. Existe o comando “let”, que permite realizar expressões matemáticas, mas é mais comum se usar a sintaxe semelhante ao C, utilizando dois parênteses:</b><br /><br />{% highlight bash %}$ a=$((1 + 1))<br />$ ((i++))<br />$ x=$((x*2))<br />...{% endhighlight %}<br /><br /><b>O Arquivo .bashrc</b><br /><b><br /></b><b>Na home dos usuários (~), é comum haver o arquivo .bashrc (o ponto no início indica que o arquivo é oculto). Esse arquivo é sempre executado quando se abre um shell. Nele, constam diversas configurações, como definição de variáveis de ambientes, definição de aliases etc. Você pode editar esse arquivo (ou criá-lo, caso não exista):</b><br /><br />{% highlight bash %}# vim ~/.bashrc{% endhighlight %}<br /><br /><b>É possível usar outros editores, não apenas o vim.</b><br /><b><br /></b><b>Aliases (Apelidos)</b><br /><b><br /></b><b>Algumas vezes usamos comandos que necessitam de várias opções e argumentos. Para amenizar o trabalho de digitarmos repetidamente estes comandos o bash oferece um recurso chamado alias com o qual podemos definir sinônimos ou “apelidos” para um comando. Um alias pode ser definido na linha de comando da seguinte forma:</b><br /><br /><i>alias nome=comando</i><br /><br /><b>Observe que não pode haver espaços em branco antes ou depois do “=”.</b><br /><b><br /></b><b>Esta sintaxe indica que nome é um “alias” (apelido) para comando. Toda vez que digitarmos o comando “nome”, o bash o substituirá por “comando”.</b><br /><b><br /></b><b>Exemplo:</b><br /><br />{% highlight bash %}# alias lf='ls -F'{% endhighlight %}<br /><br /><b>Isso fará o shell executar “ls -F” toda vez que usarmos “lf” na linha de comando. Ou seja, o que o alias faz na verdade é substituir a palavra “lf” por “ls -F”. Observe neste exemplo, existe um espaço em branco entre ls e -F. Sempre que houver espaços em branco na definição de um campo, todo o campo deve ser digitado entre aspas simples (‘) ou duplas (“).É possível definir aliases em seu .bashrc, para que eles estejam sempre disponíveis na sua sessão.</b><br /><br /><b><span style="color: #666666;">Fonte:</span></b> <a href="http://ogordo.com/curso-de-shell-script-modulo-1-scripts-shell-e-suas-estruturas/" style="color: blue;" target="_blank">O Gordo</a> e <a href="http://www.rberaldo.com.br/blog/curso-de-shell-script-modulo-1-scripts-shell-estruturas" style="color: blue;" target="_blank">rberaldo</a>